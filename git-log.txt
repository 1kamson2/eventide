diff --git a/src-engine/include/engine.hpp b/src-engine/include/engine.hpp
index fd3b440..7eebbfd 100644
--- a/src-engine/include/engine.hpp
+++ b/src-engine/include/engine.hpp
@@ -1,59 +1,39 @@
 #pragma once
-#include <cmath>
-#include <iostream>
-#include <unordered_map>
-#include <vector>
+#include <raylib.h>
 
-#include "raylib.h"
+#include "environment.hpp"
+#include "player.hpp"
 #include "resource_manager.hpp"
-using ii = std::pair<int, int>;
-#define TILE_SZ (float)16.0
-#define RENDER_DISTANCE 32
-#define SMALL_WORLD_START (float)-2048.0
-#define SMALL_WORLD_END (float)2048.0
-#define SMALL_WORLD_DEPTH 96
-#define SMALL_WORLD_WIDTH 256
-#define PLAYER_SPEED_X 100.0f
-#define PLAYER_SPEED_Y 300.0f
-#define PLAYER_JUMP TILE_SZ
-#define MAX_HEALTH_TEXT 100
-#define INVENTORY_ROWS 8
-#define INVENTORY_COLS 3
-#define GRASS_DESTROY_TIME 120  // 120 frames
-#define DIRT_DESTROY_TIME 120   // 120 frames
-#define STONE_DESTROY_TIME 300  // 300 frames
-
+// shoudlnt be hardcoded all of this
 class EventideEngine {
  public:
-  GameState State;
-  Camera2D camera;
-  Player* player;
+  // get current state of a game
+  static GameState State;
   unsigned int width, height, fps;
-  EnvTile tiles_buff[3 * RENDER_DISTANCE][3 * RENDER_DISTANCE], tree_buff[1000];
+  static Camera2D camera;
+  static PlayerObject* player;
+  // move it to the environment, this will be based on where we are
+  // probably good idea to move this buffer to another class, because
+  // we want to render more terrain, when infinite generation introduced
+  // engine will be wrapper and will check if we want to do something illegal
+  // don't want so much code cluttered
+  static EnvTile tiles_buff[3 * RENDER_DISTANCE][3 * RENDER_DISTANCE],
+      tree_buff[1000];
   std::vector<Vector2> placedRecently, removedRecently;
-  std::unordered_map<ItemType, Texture2D> envTextures;
-  Texture2D bgTexture[12];  // all layers
-  ii mouseCoords, playerIndex, treeRDist;
+  static std::unordered_map<ItemType, Texture2D> envTextures;
+  static Texture2D bgTexture[12];  // all layers
+  // up to this point ^
+  // mouse position, player index, tree rendering distance
+  ii mpos, pidx, treeRDist;
   float countdown;
   EventideEngine(unsigned int width, unsigned int height, unsigned int fps);
   virtual ~EventideEngine();
-
+  // engine's method
   void renderTiles();
   void loadTiles();
   // init events
   void eventideInit(unsigned int seed);
-  void updatePlayer(float dt);
   void processInput(float dt);
-  ii mouseWorldCoords();
-  ii findEnvPositions();
-  void tileInit(const int& x, const int& y, const float& depth,
-                const Color& color, const ItemType& it, const CanBlock& cb);
-  void treeInit(const int& pos, const Color& color, const CanBlock& cb);
-  void tileUpdate(const int& x, const int& y, const Color& color,
-                  const ItemType& it, const CanBlock& cb);
-  // check conditions
-  bool checkCollision(const EnvTile& tempET);
-  bool canModifyEnv();
   // do updates
   void update(float dt);
   void render();
diff --git a/src-engine/include/resource_manager.hpp b/src-engine/include/resource_manager.hpp
index 28cb2c7..6ddb766 100644
--- a/src-engine/include/resource_manager.hpp
+++ b/src-engine/include/resource_manager.hpp
@@ -2,8 +2,13 @@
 #include <raylib.h>
 
 #include <cassert>
-#include <cstddef>
+#include <cmath>
 #include <cstdint>
+#include <iostream>
+#include <unordered_map>
+#include <vector>
+
+using ii = std::pair<int, int>;
 #define GRASS_TEXTURE \
   "/home/kums0n-desktop/Dev/Eventide/src-engine/resources/grass-tile.png"
 #define STONE_TEXTURE \
@@ -46,6 +51,24 @@
   "/home/kums0n-desktop/Dev/Eventide/src-engine/resources/Layer_0010_1.png"
 #define LAYER11 \
   "/home/kums0n-desktop/Dev/Eventide/src-engine/resources/Layer_0011_0.png"
+#define PLAYER_TEXTURE \
+  "/home/kums0n-desktop/Dev/Eventide/src-engine/resources/crawler.png"
+#define TILE_SZ (float)16.0
+#define RENDER_DISTANCE 32
+#define SMALL_WORLD_START (float)-2048.0
+#define SMALL_WORLD_END (float)2048.0
+#define SMALL_WORLD_DEPTH 96
+#define SMALL_WORLD_WIDTH 256
+#define PLAYER_SPEED_X 100.0f
+#define PLAYER_SPEED_Y 300.0f
+#define PLAYER_JUMP TILE_SZ
+#define MAX_HEALTH_TEXT 100
+#define INVENTORY_ROWS 8
+#define INVENTORY_COLS 3
+#define GRASS_DESTROY_TIME 120  // 120 frames
+#define DIRT_DESTROY_TIME 120   // 120 frames
+#define STONE_DESTROY_TIME 300  // 300 frames
+
 enum class GameState { ACTIVE = 1, MENU = 2, DEBUGGING = 3, EXIT = -1 };
 enum class ItemType {
   AIR = 0,
@@ -62,38 +85,23 @@ enum class ItemType {
 enum class CanBlock { YES = 1, NO = 0 };
 
 struct EnvTile {
-  Rectangle rect;
-  ItemType type;
-  CanBlock blocking;
-  Color color;
-  Texture2D texture;
+  Rectangle rect = (Rectangle){0, 0, 0, 0};
+  ItemType type{ItemType::AIR};
+  CanBlock blocking{CanBlock::NO};
+  Color color{BLANK};
+  Texture2D texture = (Texture2D){0};
   // BE CAREFUL - WILL RESULT IN OVERFLOW, MORE CHECKING NEEDED.
   uint8_t quantity{1};
 };
 
-struct Player {
-  float speedY{0.0f};
-  float speedX{0.0f};
-  bool canJump{false};
-  bool canGoFaster{false};
-  bool eastCollision{false};
-  bool westCollision{false};
-  Vector2 pos;
-  Texture2D texture;
-  EnvTile hitbox;
-  EnvTile hotbar[9];
-  EnvTile inventory[3][8];
-  EnvTile health;
-};
-
 class ResourceManager {
  public:
   static Shader shaderInit();  // not implemented
   static Shader getShaders();  // not implemented
-  static Texture2D textureInit(const char* path, bool isTile);
+  static Texture2D textureInit(const char* path, float width = 16,
+                               float height = 16);
   static Texture getTextures();
   static EnvTile tileInit();
-  static Player playerInit();
-  static void Clear();
+  static void clear();
   ResourceManager() = delete;  // might cause problem? undo delete if so
 };
diff --git a/src-engine/src/engine.cpp b/src-engine/src/engine.cpp
index 8d2ae45..079c3ca 100644
--- a/src-engine/src/engine.cpp
+++ b/src-engine/src/engine.cpp
@@ -1,56 +1,45 @@
 #include "engine.hpp"
 
-#include <raylib.h>
-
+#include "environment.hpp"
+#include "player.hpp"
 #include "resource_manager.hpp"
+Camera2D EventideEngine::camera;
+GameState EventideEngine::State;
+PlayerObject* EventideEngine::player;
+EnvTile EventideEngine::tiles_buff[3 * RENDER_DISTANCE][3 * RENDER_DISTANCE],
+    EventideEngine::tree_buff[1000];
+std::unordered_map<ItemType, Texture2D> EventideEngine::envTextures;
+Texture2D EventideEngine::bgTexture[12];
+
 EventideEngine::EventideEngine(unsigned int width, unsigned int height,
                                unsigned int fps)
-    : width{width},
-      height{height},
-      fps{fps},
-      player{new Player},
-      State{GameState::ACTIVE},
-      envTextures{
-          {ItemType::GRASS, ResourceManager::textureInit(GRASS_TEXTURE, true)},
-          {ItemType::STONE, ResourceManager::textureInit(STONE_TEXTURE, true)},
-          {ItemType::DIRT, ResourceManager::textureInit(DIRT_TEXTURE, true)},
-          {ItemType::OAK_TREE,
-           ResourceManager::textureInit(OAK_TEXTURE_PATH, false)},
-          {ItemType::PINE_TREE,
-           ResourceManager::textureInit(PINE_TEXTURE_PATH, false)},
-          {ItemType::COAL,
-           ResourceManager::textureInit(COAL_TEXTURE_PATH, true)},
-          {ItemType::IRON,
-           ResourceManager::textureInit(IRON_TEXTURE_PATH, true)},
-          {ItemType::DIAMOND,
-           ResourceManager::textureInit(DIAMOND_TEXTURE_PATH, true)}} {
+    : width{width}, height{height}, fps{fps} {
   // make another function to initialize player
-  this->bgTexture[0] = ResourceManager::textureInit(LAYER0, false);
-  this->bgTexture[1] = ResourceManager::textureInit(LAYER1, false);
-  this->bgTexture[2] = ResourceManager::textureInit(LAYER2, false);
-  this->bgTexture[3] = ResourceManager::textureInit(LAYER3, false);
-  this->bgTexture[4] = ResourceManager::textureInit(LAYER4, false);
-  this->bgTexture[5] = ResourceManager::textureInit(LAYER5, false);
-  this->bgTexture[6] = ResourceManager::textureInit(LAYER6, false);
-  this->bgTexture[7] = ResourceManager::textureInit(LAYER7, false);
-  this->bgTexture[8] = ResourceManager::textureInit(LAYER8, false);
-  this->bgTexture[9] = ResourceManager::textureInit(LAYER9, false);
-  this->bgTexture[10] = ResourceManager::textureInit(LAYER10, false);
-  this->bgTexture[11] = ResourceManager::textureInit(LAYER11, false);
-  player->pos = (Vector2){SMALL_WORLD_START + 100, -5 * TILE_SZ};
-  player->speedY = 0;
-  player->canJump = false;
-  player->hitbox.rect =
-      (Rectangle){player->pos.x, player->pos.y, TILE_SZ, 3 * TILE_SZ};
-  player->hitbox.type = ItemType::PLAYER;
-  player->hitbox.blocking = CanBlock::YES;
-  player->hitbox.color = (Color){RED};
-  // health related
-  player->health.rect.width = 100;
-  player->health.rect.height = 10;
-  player->health.color = RED;
-  player->health.quantity = 100;
-
+  State = GameState::ACTIVE;
+  player = new PlayerObject();
+  envTextures = {
+      {ItemType::GRASS, ResourceManager::textureInit(GRASS_TEXTURE)},
+      {ItemType::STONE, ResourceManager::textureInit(STONE_TEXTURE)},
+      {ItemType::DIRT, ResourceManager::textureInit(DIRT_TEXTURE)},
+      {ItemType::OAK_TREE,
+       ResourceManager::textureInit(OAK_TEXTURE_PATH, 480, 120)},
+      {ItemType::PINE_TREE,
+       ResourceManager::textureInit(PINE_TEXTURE_PATH, 480, 120)},
+      {ItemType::COAL, ResourceManager::textureInit(COAL_TEXTURE_PATH)},
+      {ItemType::IRON, ResourceManager::textureInit(IRON_TEXTURE_PATH)},
+      {ItemType::DIAMOND, ResourceManager::textureInit(DIAMOND_TEXTURE_PATH)}};
+  this->bgTexture[0] = ResourceManager::textureInit(LAYER0, 1024, 1024);
+  this->bgTexture[1] = ResourceManager::textureInit(LAYER1, 1024, 1024);
+  this->bgTexture[2] = ResourceManager::textureInit(LAYER2, 1024, 1024);
+  this->bgTexture[3] = ResourceManager::textureInit(LAYER3, 1024, 1024);
+  this->bgTexture[4] = ResourceManager::textureInit(LAYER4, 1024, 1024);
+  this->bgTexture[5] = ResourceManager::textureInit(LAYER5, 1024, 1024);
+  this->bgTexture[6] = ResourceManager::textureInit(LAYER6, 1024, 1024);
+  this->bgTexture[7] = ResourceManager::textureInit(LAYER7, 1024, 1024);
+  this->bgTexture[8] = ResourceManager::textureInit(LAYER8, 1024, 1024);
+  this->bgTexture[9] = ResourceManager::textureInit(LAYER9, 1024, 1024);
+  this->bgTexture[10] = ResourceManager::textureInit(LAYER10, 1024, 1024);
+  this->bgTexture[11] = ResourceManager::textureInit(LAYER11, 1024, 1024);
   this->camera = {0};
   camera.target = (Vector2){player->pos.x + 20.0f, player->pos.y + 20.0f};
   camera.offset = (Vector2){this->width / 2.0f, this->height / 2.0f};
@@ -60,119 +49,8 @@ EventideEngine::EventideEngine(unsigned int width, unsigned int height,
 
 void EventideEngine::eventideInit(unsigned int seed) {
   SetRandomSeed(seed);
-  float depth{0};
-
-  // SMALL_WORLD_DEPTH
-  // SMALL_WORLD_STRIDE
-  for (int y = 0; y < 3 * RENDER_DISTANCE; ++y) {
-    depth = -80 + y * TILE_SZ;
-    for (int x = 0; x < 3 * RENDER_DISTANCE; ++x) {
-      int rndBlock = GetRandomValue(0, 100);
-      if (depth < 0) {
-        // AIR
-        this->tileInit(x, y, depth, BLANK, ItemType::AIR, CanBlock::NO);
-      } else if (depth == 0) {
-        // GRASS ENUM
-        this->tileInit(x, y, depth, GREEN, ItemType::GRASS, CanBlock::YES);
-      } else if (depth > 0 && depth <= 20 * TILE_SZ) {
-        if (rndBlock >= 0 && rndBlock <= 98) {
-          // DIRT ENUM
-          this->tileInit(x, y, depth, BROWN, ItemType::DIRT, CanBlock::YES);
-        } else if (rndBlock > 98 && rndBlock <= 100) {
-          // COAL ENUM
-          this->tileInit(x, y, depth, BLACK, ItemType::COAL, CanBlock::YES);
-        }
-      } else if (depth > 20 * TILE_SZ) {
-        if (rndBlock >= 0 && rndBlock <= 60) {
-          // STONE ENUM
-          this->tileInit(x, y, depth, GRAY, ItemType::STONE, CanBlock::YES);
-        } else if (rndBlock > 60 && rndBlock <= 70) {
-          // DIRT ENUM
-          this->tileInit(x, y, depth, BROWN, ItemType::DIRT, CanBlock::YES);
-        } else if (rndBlock > 70 && rndBlock <= 90) {
-          // COAL ORE
-          this->tileInit(x, y, depth, BLACK, ItemType::COAL, CanBlock::YES);
-        } else if (rndBlock > 90 && rndBlock <= 97) {
-          // IRON ENUM
-          this->tileInit(x, y, depth, GRAY, ItemType::IRON, CanBlock::YES);
-        } else if (rndBlock > 97 && rndBlock <= 100) {
-          // DIAMOND ORE
-          this->tileInit(x, y, depth, BLUE, ItemType::DIAMOND, CanBlock::YES);
-        }
-      }
-    }
-  }
-  // maybe unload textures?
-  // load trees
-  int pos = 0;
-  while (pos < 1000) {
-    pos += GetRandomValue(0, TILE_SZ / 2);
-    this->treeInit(pos, BROWN, CanBlock::NO);
-    pos += TILE_SZ;
-  }
-}
-
-void EventideEngine::tileInit(const int& x, const int& y, const float& depth,
-                              const Color& color, const ItemType& it,
-                              const CanBlock& cb) {
-  this->tiles_buff[y][x].rect =
-      (Rectangle){SMALL_WORLD_START + x * TILE_SZ, depth, TILE_SZ, TILE_SZ};
-  this->tiles_buff[y][x].color = color;
-  this->tiles_buff[y][x].type = it;
-  this->tiles_buff[y][x].blocking = cb;
-  if (it != ItemType::AIR) {
-    this->tiles_buff[y][x].texture = this->envTextures[it];
-  }
-}
-
-void EventideEngine::tileUpdate(const int& x, const int& y, const Color& color,
-                                const ItemType& it, const CanBlock& cb) {
-  this->tiles_buff[y][x].type = it;
-  this->tiles_buff[y][x].blocking = cb;
-  this->tiles_buff[y][x].color = color;
-  if (it != ItemType::AIR) {
-    this->tiles_buff[y][x].texture = this->envTextures[it];
-  } else {
-    this->tiles_buff[y][x].texture = (Texture2D){0};
-  }
-}
-
-void EventideEngine::treeInit(const int& pos, const Color& color,
-                              const CanBlock& cb) {
-  this->tree_buff[pos].rect =
-      (Rectangle){SMALL_WORLD_START + pos * TILE_SZ,
-                  (float)GetRandomValue(-10 * TILE_SZ, -9 * TILE_SZ),
-                  (float)GetRandomValue(TILE_SZ, 2 * TILE_SZ),
-                  (float)GetRandomValue(5 * TILE_SZ, 15 * TILE_SZ)};
-  this->tree_buff[pos].color = color;
-  int rndTree = GetRandomValue(0, 1);
-  switch (rndTree) {
-    case 0:
-      tree_buff[pos].texture = this->envTextures[ItemType::OAK_TREE];
-      break;
-    case 1:
-      tree_buff[pos].texture = this->envTextures[ItemType::PINE_TREE];
-      break;
-  }
-}
-bool EventideEngine::checkCollision(const EnvTile& tempET) {
-  bool collisionX =
-      player->pos.x + player->hitbox.rect.width >= tempET.rect.x &&
-      tempET.rect.x + tempET.rect.width >= player->pos.x;
-  bool collisionY =
-      player->pos.y + player->hitbox.rect.height >= tempET.rect.y &&
-      tempET.rect.y + tempET.rect.height >= player->pos.y;
-  return collisionY && collisionX;
-}
-
-bool EventideEngine::canModifyEnv() {
-  return (abs(mouseCoords.first - (int)this->player->pos.x) < 5 * TILE_SZ &&
-          abs(mouseCoords.second - (int)this->player->pos.y) < 5 * TILE_SZ);
-}
-ii EventideEngine::findEnvPositions() {
-  return ii(
-      std::max(0.0, floor((SMALL_WORLD_END + mouseCoords.first) / TILE_SZ)),
-      std::max(0.0, floor((6 * TILE_SZ + mouseCoords.second) / TILE_SZ)));
+  Environment::envInit();
+  Environment::treesInit();
 }
 void EventideEngine::processInput(float dt) {
   if (IsKeyDown(KEY_RIGHT)) {
@@ -204,9 +82,9 @@ void EventideEngine::processInput(float dt) {
     }
   } else if (IsMouseButtonPressed(MOUSE_BUTTON_LEFT)) {
     // bad cast is probable
-    if (this->canModifyEnv()) {
+    if (Environment::canModifyEnv()) {
       // add also if positions changed
-      ii pos = this->findEnvPositions();
+      ii pos = Environment::findEnvPos();
       bool canDestroy = false;
       ItemType tempET = this->tiles_buff[pos.second][pos.first].type;
 
@@ -225,8 +103,8 @@ void EventideEngine::processInput(float dt) {
         if (canDestroy) {
           canDestroy = false;
           this->countdown = 0;
-          this->tileUpdate(pos.first, pos.second, BLANK, ItemType::AIR,
-                           CanBlock::NO);
+          Environment::tileUpdate(pos.first, pos.second, BLANK, ItemType::AIR,
+                                  CanBlock::NO);
           std::cout << "Block destroyed. " << std::endl;
           if (this->removedRecently.size() >= 10) {
             this->removedRecently.clear();
@@ -237,11 +115,11 @@ void EventideEngine::processInput(float dt) {
       }
     }
   } else if (IsMouseButtonPressed(MOUSE_BUTTON_RIGHT)) {
-    if (this->canModifyEnv()) {
-      ii pos = this->findEnvPositions();
+    if (Environment::canModifyEnv()) {
+      ii pos = Environment::findEnvPos();
       if (this->tiles_buff[pos.second][pos.first].type == ItemType::AIR) {
-        this->tileUpdate(pos.first, pos.second, BROWN, ItemType::DIRT,
-                         CanBlock::YES);
+        Environment::tileUpdate(pos.first, pos.second, BROWN, ItemType::DIRT,
+                                CanBlock::YES);
         std::cout << "Block placed. " << std::endl;
         if (this->placedRecently.size() >= 10) {
           this->placedRecently.clear();
@@ -253,86 +131,12 @@ void EventideEngine::processInput(float dt) {
   }
 }
 
-void EventideEngine::updatePlayer(float dt) {
-  // update health ui
-  player->hitbox.rect.y = player->pos.y;
-  player->hitbox.rect.x = player->pos.x;
-  player->health.rect.x = player->pos.x - 125;
-  player->health.rect.y = player->pos.y - 70;
-  // update camera
-  if (player->pos.x > SMALL_WORLD_START + 10 * TILE_SZ &&
-      player->pos.x < SMALL_WORLD_END - 10 * TILE_SZ) {
-    camera.target = (Vector2){player->pos.x + player->hitbox.rect.width / 2,
-                              player->pos.y + player->hitbox.rect.height / 2};
-  }
-  // update hotbar
-  for (int i = 0; i < 9; ++i) {
-    this->player->hotbar[i].rect =
-        (Rectangle){player->pos.x - 62.5f + 1.2f * TILE_SZ * i,
-                    player->pos.y + 125, TILE_SZ, TILE_SZ};
-    this->player->hotbar[i].color = WHITE;
-  }
-  for (int i = 0; i < 3; ++i) {
-    for (int j = 0; j < 8; ++j) {
-      this->player->inventory[i][j].rect = (Rectangle){
-          player->pos.x - 125.0f + 1.2f * TILE_SZ * i,
-          player->pos.y - 50.0f + 1.2f * j * TILE_SZ, TILE_SZ, TILE_SZ};
-      this->player->inventory[i][j].color = WHITE;
-    }
-  }
-
-  bool hitObstacle = false;
-  for (int y = 0; y < 3 * RENDER_DISTANCE; y++) {
-    for (int x = 0; x < 3 * RENDER_DISTANCE; ++x) {
-      EnvTile tempET = this->tiles_buff[y][x];
-      Vector2 playerPos = player->pos;
-      if (tempET.blocking == CanBlock::YES && this->checkCollision(tempET)) {
-        std::cout << "[DEBUG] Collision detected on: " << tempET.rect.x << " "
-                  << tempET.rect.y << std::endl;
-        hitObstacle = true;
-        playerPos.y = tempET.rect.y;
-        player->speedY = 0.0f;
-        if (this->player->pos.y + this->player->hitbox.rect.height >
-            tempET.rect.y + tempET.rect.height) {
-          if (this->player->pos.x - tempET.rect.x - tempET.rect.width < 0) {
-            this->player->westCollision = true;
-          }
-          if (tempET.rect.x - this->player->pos.x -
-                  this->player->hitbox.rect.width <
-              0) {
-            this->player->eastCollision = true;
-          } else {
-            this->player->westCollision = false;
-            this->player->eastCollision = false;
-          }
-        }
-      }
-    }
-  }
-  // jumping works weird...
-  if (!hitObstacle) {
-    this->player->westCollision = false;
-    this->player->eastCollision = false;
-    player->speedY = PLAYER_SPEED_Y;
-    player->pos.y += this->player->speedY * dt;
-    player->canJump = false;
-    player->canGoFaster = true;
-  } else {
-    player->canJump = true;
-    player->canGoFaster = false;
-  }
-}
 void EventideEngine::update(float dt) {
   this->processInput(dt);
-  this->updatePlayer(dt);
-  this->mouseCoords = ii(this->player->pos.x + GetMouseX() - 300,
-                         this->player->pos.y + GetMouseY() - 280);
-  // this->renderTiles();
-  this->playerIndex = ii(ceil((player->pos.x - SMALL_WORLD_START) / TILE_SZ),
-                         ceil(player->pos.y / TILE_SZ));
-  this->treeRDist =
-      ii(std::max((int)(this->playerIndex.first), 0),
-         std::min(3 * RENDER_DISTANCE, (int)(this->playerIndex.first)));
+  this->player->updatePlayerState(dt);
+  // render related = engine
+  this->treeRDist = ii(std::max((int)(this->pidx.first), 0),
+                       std::min(3 * RENDER_DISTANCE, (int)(this->pidx.first)));
 }
 
 void EventideEngine::renderTiles() {
@@ -345,8 +149,8 @@ void EventideEngine::debug() {
   std::cout << "[DEBUG] FPS: " << GetFPS() << std::endl;
   std::cout << "[DEBUG] PLAYER POS [X, Y]: " << this->player->pos.x << " "
             << this->player->pos.y << std::endl;
-  std::cout << "[DEBUG] MOUSE POS: " << this->mouseCoords.first << " "
-            << this->mouseCoords.second << std::endl;
+  std::cout << "[DEBUG] MOUSE POS: " << this->mpos.first << " "
+            << this->mpos.second << std::endl;
   std::cout << "[DEBUG] Recently placed blocks: " << std::endl;
   std::cout << "[DEBUG] ARRAY[y][x] REAL COORDS: [x, y] " << std::endl;
   for (const Vector2 el : this->placedRecently) {
@@ -364,6 +168,7 @@ void EventideEngine::debug() {
 }
 
 EventideEngine::~EventideEngine() {
+  std::cout << "Eventide Engine: Cleaning up..." << std::endl;
   delete player;
   player = nullptr;
 }
diff --git a/src-engine/src/main.cpp b/src-engine/src/main.cpp
index 7add67c..e4b7a4e 100644
--- a/src-engine/src/main.cpp
+++ b/src-engine/src/main.cpp
@@ -1,7 +1,6 @@
 #include <raylib.h>
 
 #include "engine.hpp"
-#include "resource_manager.hpp"
 int main() {
   SetConfigFlags(FLAG_WINDOW_RESIZABLE);
   InitWindow(640, 480, "Test");
@@ -86,8 +85,6 @@ int main() {
   return 0;
 }
 // bind ui to camera not the player...
-// Make Inventory - done.
-// Add ores.
 // Infinite world generation.
 // Fix placing and destroying - works better, the same as down below, add
 // intervals. Fix collisions - works better, add case by case if x < 0 and x >
diff --git a/src-engine/src/resource_manager.cpp b/src-engine/src/resource_manager.cpp
index 0155867..9466645 100644
--- a/src-engine/src/resource_manager.cpp
+++ b/src-engine/src/resource_manager.cpp
@@ -2,9 +2,8 @@
 
 #include <raylib.h>
 
-#include "engine.hpp"
-
-Texture2D ResourceManager::textureInit(const char* path, bool isTile = false) {
+Texture2D ResourceManager::textureInit(const char* path, float width,
+                                       float height) {
   Image img = LoadImage(path);
   if (img.data == NULL) {
     std::cerr << "[WARNING] Image data is null! This error occurred for:"
@@ -12,11 +11,12 @@ Texture2D ResourceManager::textureInit(const char* path, bool isTile = false) {
     std::cerr << path << std::endl;
     exit(0);
   }
-  if (isTile) {
-    ImageResize(&img, TILE_SZ, TILE_SZ);
-  } else {
-    ImageResize(&img, 200, 200);
-  }
+  std::cout << " " << path << std::endl;
+  printf(
+      "[Image info]:\nLoading Image: %s\nWIDTH: %.3f\nHEIGHT: %.3f\nASPECT "
+      "RATIO: %.3f",
+      path, width, height, width / height);
+  ImageResize(&img, width, height);
   Texture2D texture = LoadTextureFromImage(img);
   UnloadImage(img);
   return texture;
